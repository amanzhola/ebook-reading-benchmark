# Ebook Reading Benchmark

Мини-проект для сравнения разных структур данных  
для задачи отслеживания прогресса чтения электронной книги.

В репозитории есть:
- solution.cpp — финальное решение для сдачи (строгий формат ввода/вывода по ТЗ)
- bench/ — альтернативные реализации + генератор для нагрузочного тестирования
- Makefile — удобные команды сборки, запуска и сравнения результатов
- sample.txt — пример входных данных из условия задачи

---

## Задача

Поддерживаются запросы:

- READ user page — пользователь user дочитал книгу до страницы page  
  (для каждого пользователя номера страниц строго возрастают)
- CHEER user — доля существующих читателей (кроме самого user),
  прочитавших меньше страниц

Особые случаи:
- если у пользователя не было READ, то ответ CHEER = 0  
  и он не участвует в статистике
- если читатель один, то доля считается равной 1

Ограничения:
- до 1 000 000 запросов
- до 100 000 пользователей
- до 1000 страниц

---

## Реализованные решения

Решение        | Идея                                       | READ     | CHEER
---------------|---------------------------------------------|----------|----------
Naive          | Массив at_least[page], обновление циклом   | O(page)  | O(1)
Sqrt-decomp    | √-декомпозиция по страницам                | O(1)     | O(√P)
Fenwick Tree   | Дерево Фенвика по страницам                | O(log P) | O(log P)

Где P = 1000.

---

## Структура проекта

.
├── Makefile
├── README.md
├── solution.cpp
├── sample.txt
└── bench
    ├── generator.cpp
    ├── reading_naive.cpp
    ├── reading_sqrt.cpp
    ├── reading_fenwick.cpp
    └── log_duration.h

---

## Файлы проекта

solution.cpp  
Финальная версия для сдачи.  
Печатает только ответы на CHEER в stdout.  
Формат вывода: setprecision(6).

sample.txt  
Пример входных данных из условия задачи.  
Используется для быстрой проверки корректности решения.

bench/reading_naive.cpp, bench/reading_sqrt.cpp, bench/reading_fenwick.cpp  
Альтернативные реализации для сравнения алгоритмов.

bench/generator.cpp  
Генератор больших тестов с усиленной нагрузкой на операции READ.

bench/log_duration.h  
Общий RAII-таймер LogDuration, используемый в бенчмарках
для замеров времени выполнения (подключается опционально).

Makefile  
Команды для сборки, генерации входных данных,  
проверки корректности и замеров производительности  
(адаптирован под Windows + MinGW).

---

## Пример входных данных

Пример входных данных из условия задачи находится в файле sample.txt  
в корне проекта.

Ожидаемый вывод для sample.txt:

0
1
0
0.5
0.5
1
0.5

---

## Быстрый старт (Windows / MinGW)

В Windows используется mingw32-make вместо make.

---

1) Сборка финального решения

mingw32-make solution

---

2) Запуск на примере из условия

solution.exe < sample.txt

Вывод должен совпадать с ожидаемым, приведённым выше.

---

3) Генерация большого входного файла

mingw32-make gen

Будет создан файл input.txt (~1 000 000 запросов).

---

4) Запуск решения на большом тесте

solution.exe < input.txt > out.txt

---

5) Сборка всех реализаций для сравнения

mingw32-make bench

---

6) Проверка корректности (сравнение вывода)

mingw32-make diff

Если всё корректно, будет выведено:

OK: outputs match

---

## Бенчмарк по времени (опционально)

Для замеров используется макрос ENABLE_BENCHMARK.

Код таймингов вынесен в общий файл bench/log_duration.h  
и подключается только при компиляции с этим макросом.

- ответы CHEER перенаправляются в NUL
- замеры времени выводятся в stderr и видны в терминале

---

7) Замер времени только Fenwick

mingw32-make bench_time

Пример вывода:

=== FENWICK ===
Input: 204 ms
Algo:  96 ms
Fenwick TOTAL: 349 ms

---

8) Замер времени всех реализаций

mingw32-make bench_all_time

Пример вывода:

=== NAIVE ===
Input: 208 ms
Algo:  418 ms
Naive TOTAL: 675 ms

=== SQRT ===
Input: 201 ms
Algo:  92 ms
Sqrt TOTAL: 340 ms

=== FENWICK ===
Input: 204 ms
Algo:  96 ms
Fenwick TOTAL: 349 ms

---

9) Очистка проекта

mingw32-make clean

После clean удаляются собранные .exe и сгенерированный input.txt.  
Чтобы снова запустить решение на большом тесте, нужно выполнить:

mingw32-make solution  
mingw32-make gen

---

## Выводы

- Naive-решение сильно проигрывает из-за обновлений с асимптотикой O(page).
- Sqrt-decomposition и Fenwick Tree работают на порядки быстрее.
- При большом объёме данных основным узким местом часто становится ввод, а не алгоритм.
- Fenwick Tree показывает лучший баланс между простотой реализации и асимптотикой.

Проект предназначен для учебного сравнения алгоритмических подходов  
и анализа влияния асимптотики и I/O на производительность.
